#include <stdio.h>
#include <string.h>
#include <stdlib.h>
#include <unistd.h>
#include <netinet/in.h>
#include <arpa/inet.h>
#include <sys/socket.h>
#include <pthread.h>
#include <time.h>
#include <ctype.h>

int serverfd;
int clientfd[100];
int size = 6;
char* IP = "127.0.0.1";
short PORT = 6667;
typedef struct sockaddr meng;
int client_count = 0;
time_t nowtime;

void init(){

    serverfd = socket(PF_INET,SOCK_STREAM,0);

    if (serverfd == -1){
        perror("Creatling socket failed!");
        exit(-1);
    }


    struct sockaddr_in addr;
    addr.sin_family = PF_INET;
    addr.sin_port = htons(PORT);
    addr.sin_addr.s_addr = inet_addr(IP);


    if (bind(serverfd,(meng*)&addr,sizeof(addr)) == -1){
       perror("Binding failed!");
       exit(-1);
    }

    if (listen(serverfd,100) == -1){
        perror("Listening failed!");
        exit(-1);
    }

}

void node_server(){
    printf("Starts Node Server\n");

    while(1){

        struct sockaddr_in fromaddr;

        socklen_t len = sizeof(fromaddr);

        // printf("Waiting for client to connect...\n");
        int fd = accept(serverfd,(meng*)&fromaddr,&len);


        if (fd == -1){
            continue;
        }

        int i = 0;


        //check Id
        char id[30] = {};
        recv(fd, id, sizeof(id), 0);
        // char id[30];
        // strcpy(id, temp);
        
        printf("Recv: %s\n", id);
        close(fd);

    }

    close(serverfd);
    // printf("Recv: %s\n", id);
}

int main(){
    init();
    node_server();
}

/* -----------------------------*/
#include <stdio.h>
#include <stdlib.h>
#include <string.h>

// Node structure for a linked list
typedef struct Node {
    char data;
    struct Node* next;
} Node;

// Structure for the queue
typedef struct {
    Node* front;
    Node* rear;
} Queue;

// Function to initialize an empty queue
void initializeQueue(Queue* q) {
    q->front = q->rear = NULL;
}

// Function to enqueue a character
void enqueue(Queue* q, char data) {
    Node* newNode = (Node*)malloc(sizeof(Node));
    newNode->data = data;
    newNode->next = NULL;

    if (q->rear == NULL) {
        q->front = q->rear = newNode;
    } else {
        q->rear->next = newNode;
        q->rear = newNode;
    }
}

// Function to dequeue a character
char dequeue(Queue* q) {
    if (q->front == NULL) {
        // Queue is empty
        return '\0';
    }

    char data = q->front->data;
    Node* temp = q->front;

    q->front = q->front->next;

    if (q->front == NULL) {
        q->rear = NULL;
    }

    free(temp);

    return data;
}

// Function to check if the queue is empty
int isQueueEmpty(Queue* q) {
    return q->front == NULL;
}

int main() {
    // Given char string
    const char data[] = "welcome, hello!";

    // Size of the buffer
    const int bufferSize = 5;

    // Calculate the length of the data string
    int dataLength = strlen(data);

    // Queue for the buffer
    Queue q1, q2, q3, q4, q5;
    initializeQueue(&q1);
    initializeQueue(&q2);
    initializeQueue(&q3);

    // Loop through the data string
    for (int i = 0; i < dataLength; i++) {
        // Enqueue characters into the buffer
        enqueue(&q1, data[i]);

        // If the buffer is full or we reach the end of the data string
        if (isQueueEmpty(&q1) || i == dataLength - 1) {
            // Print the buffer
            // printf("Buffer: ");

            while (!isQueueEmpty(&q1)) {
                char c = dequeue(&q1);
                printf("Buffer: %c\n", c);
            }

            printf("\n");
        }
    }

    return 0;
}
